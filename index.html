<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/node_modules/kaboom/dist/kaboom.js"></script>
  <title>Document</title>
</head>

<body>
  <script>
    const tile = 64
    const row = 9
    const col = 9
    const canvas_width = tile * row
    const canvas_height = tile * col
    let cooldown = false
    let color_cream = [246,241,210]
    let color_flesh = [240,210,200]
    let color_blue = [0,48,73]
    let color_red = [214,40,40]

    kaboom({
      width: canvas_width,
      height: canvas_height
    })

    loadSprite('hero', '/assets/sprites/dark_hair_boy_60x60.png',
      {
        sliceX: 22,
        anims: {
          runX: {
            from: 12,
            to: 15
          },
          runY_fup: {
            from: 0,
            to: 4
          },
          runY_fdown: {
            from: 6,
            to: 11
          },
          idle: {
            from: 18,
            to: 18
          },
        }
      })

    for (c = 0; c < col; c++) {
      for (r = 0; r < row; r++) {
        cX = r * tile
        rY = c * tile
        
        if(r % 2 == 0 || c % 2 == 0)
        {
          tiles = add([
          rect(tile, tile),
          pos(cX, rY),
          color(color_cream),
          'tiles',
          outline(1,rgb(184,231,202))
        ])
        }
        else
        {
          tiles = add([
          rect(tile, tile),
          pos(cX, rY),
          'tiles',
          outline(1,rgb(184,231,202)),
          color(color_blue)
        ])
        }

      }
    }
    let allTiles = get('tiles')
    let countY = 0
    let countX = 0

    hero = add([
      sprite('hero'),
      pos(0, 0),
      area(),

    ])


    hero.play('idle')
    allTiles[0].color = rgb(color_flesh)

    onKeyPress('down', () => {
      if (countY <= col * (col - 2) && cooldown == false) {
        hero.play('runY_fup')
        countY += col
        allTiles[countY + countX].color = rgb(color_flesh)
        allTiles[countY - col + countX].color = rgb(color_cream)
        cooldown = true
        move = setInterval(() => {
          if (hero.pos.y <= allTiles[countY + countX].pos.y) {
            hero.move(0, 200)

          }
          else {

            clearInterval(move)
            setTimeout(() => { cooldown = false }, 1)
          }
        }, 1)
      }

    })
    onKeyPress('up', () => {
      if (countY >= 1 && cooldown == false) {
        hero.play('runY_fdown')
        countY -= col
        allTiles[countY + countX].color = rgb(color_flesh)
        allTiles[countY + col + countX].color = rgb(color_cream)
        cooldown = true
        move = setInterval(() => {
          if (hero.pos.y >= allTiles[countY + countX].pos.y) {
            hero.move(0, -200)

          }
          else {
            setTimeout(() => { cooldown = false }, 1)
            clearInterval(move)


          }
        }, 1)

      }

    })


    onKeyPress('right', () => {
      if (countX <= row - 2 && cooldown == false) {
        hero.play('runX')
        console.log(countX++)
        allTiles[countY + countX].color = rgb(color_flesh)
        allTiles[countX - 1 + countY].color = rgb(color_cream)
        cooldown = true
        hero.flipX(0)

        move = setInterval(() => {
          if (hero.pos.x <= allTiles[countY + countX].pos.x) {
            hero.move(200, 0)


          }
          else {
            setTimeout(() => { cooldown = false }, 1)

            clearInterval(move)

          }
        }, 1)
      }

    })


    onKeyPress('left', () => {
      if (countX >= 1 && cooldown == false) {
        hero.play('runX')
        hero.flipX(1)
        countX--
        allTiles[countY + countX].color = rgb(color_flesh)
        allTiles[countX + 1 + countY].color = rgb(color_cream)
        cooldown = true


        move = setInterval(() => {
          if (hero.pos.x >= allTiles[countY + countX].pos.x) {
            hero.move(-200, 0)

          }
          else {
            clearInterval(move)
            setTimeout(() => { cooldown = false }, 1)

          }

        }, 1)
      }
    })





  </script>
</body>

</html>